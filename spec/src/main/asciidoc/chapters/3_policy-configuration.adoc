[[a232]]
== Policy Configuration Subcontract

The <<a232>> defines the interactions between container
deployment tools and providers to support the translation of declarative
Jakarta EE authorization policy into policy statements within a Java SE
Policy provider.

This subcontract also applies to the
translation of authorization policy annotations that have an equivalent
representation in Jakarta EE deployment descriptor policy constructs (i.e.,
`security-constraint`, `method-permission`, `security-role-ref`, and
`exclude-list` elements).

[[a235]]
=== What a Jakarta EE Platform’s Deployment Tools Must Do

The `getPolicyConfigurationFactory` method
must be used in every JRE to which the components of the application or
module are being deployed to find or instantiate
PolicyConfigurationFactory objects.

[source,java]
----
PolicyConfigurationFactory policyConfigurationFactory =
    PolicyConfigurationFactory.getPolicyConfigurationFactory();
----

The `getPolicyConfiguration` method of the
factories must be used to find or instantiate `PolicyConfiguration`
objects corresponding to the application or modules being deployed.

[source,java]
----
String petContextID = "acme-pet-server /petstore";

PolicyConfiguration petPolicyConfiguration =
    policyConfigurationFactory.getPolicyConfiguration(petContextID, true);
----

The declarative authorization policy
statements derived from the application or module deployment
descriptor(s) must be translated to create instances of the
corresponding `jakarta.security.jacc` Permission classes.

[source,java]
----
WebResourcePermission webResourcePermission =
    new WebResourcePermission("/elephant", "GET");
----

Methods of the `PolicyConfiguration`
interface must be used with the permissions resulting from the
translation to create policy statements within the `PolicyConfiguration`
objects.

[source,java]
----
petPolicyConfiguration.addToRole("customer", webResourcePermission);
----

The `PolicyConfiguration` objects must be
linked such that the same principal-to-role mapping will be applied to
all the modules of the application.

[source,java]
----
petPolicyConfiguration.linkConfiguration(petFoodPolicyConfiguration);
----

The PolicyConfiguration objects must be
placed in Service such that they will be assimilated into the Policy
providers used by the containers to which the application has been
deployed.

[source,java]
----
petPolicyConfiguration.commit();
----


Independent of this specification, Jakarta EE
deployment tools must translate and complete the declarative policy
statements appearing in deployment descriptors into a form suitable for
securing applications on the platform. These
deployment tools must combine policy annotations in Java code with
policy statements appearing in deployment descriptors to yield complete
representations of authorization policy suitable for securing
applications on the platform. The rules for combining authorization
policy annotations with declarative policy statements are described in
the Jakarta Enterprise Beans, Jakarta Servlet, and Jakarta EE platform specifications. 
Independent of whether
annotations factor in the translation, the resulting policy statements
may differ in form from the policy statements appearing in the
deployment descriptors. The policy translation defined by this
subcontract is described assuming that the policy statement form used by
a platform is identical to that used to express policy in the deployment
descriptors. Where this is not the case, the output of the translation
must be equivalent to the translation that would occur if policy was
completely specified in the deployment descriptors and the translation
had proceeded directly from the deployment descriptors to the Java SE
policy forms defined by this subcontract. Two translations are
equivalent if they produce corresponding collections of unchecked,
excluded, and role permissions, and if all of the permissions of each
such collection are impliedfootnote:[For some permission types, such as the `EJBMethodPermission`, it will generally not be possible to use the implies method of the `PermissionCollection` to compute collection equivalence (because the implies method is unable to determine when a collection contains all the permissions implied by a wild carded form of the permission).]
by the permissions of
the corresponding or excluded collection of the other translation.
Translation equivalence is only required with respect to the permission
types that are the subject of the translation.

[[a253]]
==== Policy Contexts and Policy Context Identifiers

It must be possible to define separate
authorization policy contexts corresponding to each deployed instance of
a Jakarta EE module. This per module scoping of policy context is necessary
to provide for the independent administration of policy contexts
corresponding to individual application modules (perhaps multiply
deployed) within a common `Policy` provider.

Each `policy` context contains all of the
policy statements (as defined by this specification) that effect access
to the resourcesfootnote:[An exception to this rule is described in <<a512>>.]
in one or more deployed modules.
At policy configuration, a `PolicyConfiguration` object is created for
each policy context, and populated with the policy statements
(represented by permission objects) corresponding to the context. Each
policy context has an associated policy context identifier.

In the <<a556>>, access decisions are
performed by checking permissions that identify resources by name and
perhaps action. When a permission is checked, this specification
requires identification of the authorization policy context in which the
evaluation is to be performed (<<a707>>).

[[a257]]
===== Policy Context Life Cycle

<<a268>> depicts the policy context life cycle
as effected through the methods of the `PolicyConfiguration` interface. A
policy context is in one of three states and all implementations of the
`PolicyConfiguration` interface must implement the state semantics defined
in this section.

*  open
+
A policy context in the open state must be
available for configuration by any of the methods of the
PolicyConfiguration interface. A policy context in the open state must
not be assimilated at Policy.refresh into the policy statements used by
the Policy provider in performing its access decisions.

* inService
+
A policy context in the inService state must
be assimilated at `Policy.refresh` into the policy statements used by its
provider. When a provider's refresh method is called, it must assimilate
only policy contexts that are in the inService state and it must ensure
that the policy statements put into service for each policy context are
only those defined in the context at the time of the call to refresh. A
policy context in the inService state must be unavailable for additional
configuration. A policy context in the inService state must be
transitioned to the open state when it is returned as a result of a call
to `getPolicyConfiguration`. A policy context is transitioned to the
inService state by calling the commit method, and only a policy context
in the open state may be transitioned to the inService state.

* deleted
+
A policy context in the deleted state must be
unavailable for configuration and it must be unavailable for
assimilation into its associated Provider. A policy context in the
deleted state must be transitioned to the open state when it is returned
as a result of a call to `getPolicyConfiguration`. A policy context is
transitioned to the deleted state by calling the delete method.

Note that for a provider implementation to be
compatible with multi-threaded environments, it may be necessary to
synchronize the refresh method of the provider with the methods of its
`PolicyConfiguration` interface and with the `getPolicyConfiguration` and
inService methods of its `PolicyConfigurationFactory`.

[[a268]]
image::PolicyConfigurationStateTable.png[caption="Figure {doc-part}-{counter:figure} ", reftext="Figure {doc-part}-{figure}", title="PolicyConfiguration State Table", align="center",width=300]


[[a269]]
===== Linking Policy Contexts

In the Jakarta EE security model,
principal-to-role mappings have application scope; that is, the same
principal-to-role mappings must apply in the access decisions applied at
all of the modules (that may represent separate policy contexts) that
comprise an application. Same application policy contexts must be
associated by calling the `PolicyConfiguration.linkConfiguration`
method. This method must create a transitive and symmetric relationship
within the provider and between this `PolicyConfiguration` and the
argument `PolicyConfiguration` , such that they and all
`PolicyConfiguration` objects otherwise linked to either of them share the
same principal-to-role mappings. The semantics of the association must
preserve the invariant that at most one principal-to-role mapping may
apply to any `PolicyConfiguration` .

[[a271]]
==== Servlet Policy Context Identifiers

Servlet requests may be directed to a logical
host using various physical or virtual host names or addresses, and an
application server may be composed of multiple logical hosts. A virtual
application server may be realized as a cluster of physical application
servers, each hosting some subset of the logical hosts of the virtual
application server. This specification uses the term hostname to refer
to the name of a logical host that processes Servlet requests. A servlet
container is responsible for mapping the target name or address
information of an HTTP request to the appropriate hostname.

To satisfy this specification, an application
server must establish servlet policy context identifiers sufficient to
differentiate all instances of a web application deployed on the logical
host or on any other logical host that may share the same policy
statement repository. One way to satisfy this requirement is to compose
policy context identifiers by concatenating the hostname with the
context path (as defined in the Servlet specification) identifying the
web application at the host.

When an application is composed of multiple
web modules, a separate policy context must be defined per module. This
is necessary to ensure that url-pattern based and servlet name based
policy statements configured for one module do not interfere with those
configured for another.

The policy contexts assigned
to web applications and web modules must be distinct from those to which
any Jakarta Enterprise Beansfootnote:[See <<a512>> for further clarification.] 
components are assigned.

[[a276]]
==== Translating Servlet Deployment Descriptors

A reference to a `PolicyConfiguration` object
must be obtained by calling the `getPolicyConfiguration` method on the
`PolicyConfigurationFactory` implementation class of the provider
configured into the container. The policy context identifier used in the
call to the `getPolicyConfiguration` method must be a `String` composed
as described in <<a271>>. The `security-constraint` and `security-role-ref` elements
in the deployment descriptor must be translated into permissions and
added to the `PolicyConfiguration` object as defined in the following
sections. Before the translation is performed, all policy statements
must have been removedfootnote:[This can be achieved by passing true as the second parameter in the call to
`getPolicyConfiguration`, or by calling delete on the `PolicyConfiguration` before calling `getPolicyConfiguration` to transition it to the open state.] 
from the policy context
associated with the returned `PolicyConfiguration`.

[[a278]]
===== Programmatic Servlet Registrations

Jakarta Servlet containers support the
programmatic registration and security configuration of servlets. 
The servlet policy
translation defined by this subcontract is described assuming that all
such programmatic registration and security configuration has completed
(for the servlet module corresponding to the policy context) before the
translation is performed and that the resulting security related
configuration has been represented in its equivalent form within the
deployment descriptors on which the translation is performed. Where this
is not the case, the result of the translation must be equivalent, as
described previously, to the translation that would occur if it was the
case. The mapping to equivalent deployment descriptor representation of
security related configuration corresponding to programmatically
registered servlets is defined in the Jakarta Servlet specification.

If the results of a prior translation are
invalidated by subsequent programmatic registration and security
configuration (as might occur if an initial translation is performed
before the programmatic effects), the translation must be repeated.
Before the translation is repeated, a reference must be obtained to the
`PolicyConfiguration` object in the open state, and its policy
statements must be removed. If the PolicyConfiguration has already been
linked to other committed policy contexts, then it may be necessary or
preferable (in order to satisfy the linking requirements defined in
<<a527>>)
to obtain the reference and remove the policy statements while
preserving the linkages established for the context by the prior
translation. Policy statements may be removed while preserving linkages
by calling the `removeUncheckedPolicy`, `removeExcludedPolicy`, and
`removeRole` methods on the open `PolicyConfiguration` object.

[[a281]]
===== Translating security-constraint Elements

The paragraphs of this section describe the
translation of security-constraints into `WebResourcePermission` and
`WebUserDataPermission` objects constructed using qualified URL pattern
names. In the exceptional case, as defined in
<<a288>>, where a
pattern is made irrelevant by a qualifying pattern, the permission
instantiations that would result from the translation of the pattern, as
described below, must not be performed. Otherwise, the translation of
URL patterns in security constraints must yield an equivalent
translation to the translation that would result from following the
instructions in the remainder of this section.

A `WebResourcePermission` and a
`WebUserDataPermissionfootnote:[The WebUserDataPermission objects allow a container to determine when to reject a request before redirection if it would ultimately be rejected as the result of an excluding auth-constraint]` object must be added to the
excluded policy statements for each distinct `url-pattern` occurring
in the `security-constraint` elements that contain an
`auth-constraint` naming no roles (i.e an excluding `auth-constraint`). 
The permissions must be constructed using the qualified (as defined
in <<#a288>>)
pattern as their name and with actions obtained by combining (as defined
in <<a302>>) the
collections containing the pattern and occurring in a constraint with an
excluding `auth-constraint`. The constructed permissions must be
added to the excluded policy statements by calling the
`addToExcludedPolicy` method on the `PolicyConfiguration` object.

A `WebResourcePermission` must be added to
the corresponding role for each distinct combination in the
cross-product of` `url-pattern` and `role-name` occurring in the
`security-constraint` elements that contain an `auth-constraint`
naming roles. If the “any authenticated user” role-name, pass:[“**”], occurs
in an auth-constraint, a `WebResourcePermission` must also be added to the
pass:[“**”] role. When an` `auth-constraint` names the reserved `role-name`
, pass:["*"], all of the patterns in the containing` `security-constraint`
must be combined with all of the roles defined in the web application;
which must not include the role pass:[“**”] unless the application has defined
an application role named pass:[“**”]. Each `WebResourcePermission` object must
be constructed using the qualified pattern as its name and with actions
defined by combining (as defined in <<a302>>) the collections containing the pattern and
occurring in a constraint that names (or implies via pass:["*"]) the role to
which the permission is being added. The resulting permissions must be
added to the corresponding roles by calling the `addToRole` method on
the `PolicyConfiguration` object.

A WebResourcePermission must be added to
the unchecked policy statements for each distinct `url-pattern`
occurring in the `security-constraint` elements that do not contain
an `auth-constraint`. Each `WebResourcePermission` object must be
constructed using the qualified pattern as its name and with actions
defined by combining (as defined in <<a302>>) the collections containing the pattern and
occurring in a `security-constraint` without an `auth-constraint`.
The resulting permissions must be added to the unchecked policy
statements by calling the `addToUncheckedPolicy` method on the
`PolicyConfiguration` object.

A `WebUserDataPermission` must be added to
the unchecked policy statements for each distinct combination of
`url-pattern` and acceptable connection type resulting from the
processing of the `security-constraint` elements that do not contain
an excluding `auth-constraint`. The mapping of `security-constraint` to
acceptable connection type must be as defined in
<<a330>>. Each `WebUserDataPermission` object must be constructed
using the qualified pattern as its name and with actions defined by
appendingfootnote:[The value null should be used as the actions value in the construction of a `WebUserDataPermission` when both the HTTP method specification, and the representation of the acceptable connection type may be represented by null. If only one of the action components may be represented by null the other should be used as the actions value.] a representation of the acceptable
connection type to the HTTP method specification obtained by combining
(as defined in <<a302>>)
the collections containing the pattern and occurring in a
`security-constraint` that maps to the connection type and that does
not contain an excluding `auth-constraint`. The resulting permissions
must be added to the unchecked policy statements by calling the
`addToUncheckedPolicy` method on the `PolicyConfiguration` object.

A `WebResourcePermission` and a `WebUserDataPermission` must be obtained for each 
`url-pattern` in the deployment descriptor and the default pattern, "/", that is
not combined by the` `web-resource-collection` elements of the deployment descriptor
with every possible HTTP method valuefootnote:[The set of all possible HTTP methods is non-enumerable and contains the traditional HTTP methods (i.e., DELETE, GET, HEAD, OPTIONS, POST, PUT, TRACE) and any method conforming to the “extension-method” syntax defined in IETF RFC 2616 “Hypertext Transfer Protocol -- HTTP/1.1”. A null or the emptyString HTTP method specification is used to this set.]. 
The permission objects must be constructed using the qualified pattern as
their name and with actions represented by an HTTP method specification
that identifies all of the HTTP methods that do not occur in combination
with the pattern. The form of the HTTP method specification used in the
permission construction depends on the representation of the methods
that occurred in combination with the pattern. If the methods that
occurred are represented by an `HttpMethodExceptionList` as defined in
<<a318>>), the
permissions must be constructed using an HTTPMethodList naming all of
the HTTP methods named in the exception list. Conversely, if the methods
that occurred are represented by an `HTTPMethodList`, the permissions must
be constructed using an `HTTPMethodExceptionList` naming all of the HTTP
methods that occurred with the pattern. If a deny uncovered HTTP methods
semantic is in effect for the web module associated with the
`PolicyContext`, the resulting permissions must be added to the excluded
policy statements by calling the `addToExcludedPolicy` method on the
`PolicyConfiguration` object. Otherwise, the permissions must be added
to the unchecked policy statements by calling the `addToUncheckedPolicy`
method on the `PolicyConfiguration` object.

[[a288, "Qualified URL Pattern Names"]]
*Qualified URL Pattern Names*

The URL pattern qualification described in
this section serves to capture the best-matching semantics of the
Jakarta Servlet constraint model in the qualified names such that the
`WebResourcePermission` and `WebUserDataPermission` objects can be tested
using the standard Java SE permission evaluation logic.

The `WebResourcePermission` and `WebUserDataPermission` objects resulting
from the translation of a Jakarta Servlet deployment descriptor must be constructed with a 
name produced by qualifying the URL pattern. The rules for qualifying a URL pattern
are dependent on the rules for determining if one URL pattern matches
another as defined in <<a347>>, and are described as follows:

* If the pattern is a path prefix pattern, it
must be qualified by every path-prefix pattern in the deployment
descriptor matched by and different from the pattern being qualified.
The pattern must also be qualified by every exact pattern appearing in
the deployment descriptor that is matched by the pattern being
qualified.
* If the pattern is an extension pattern, it
must be qualified by every path-prefix pattern appearing in the
deployment descriptor and every exact pattern in the deployment
descriptor that is matched by the pattern being qualified.
* If the pattern is the default pattern, "/",
it must be qualified by every other pattern except the default pattern
appearing in the deployment descriptor.
* If the pattern is an exact pattern, its
qualified form must not contain any qualifying patterns.

URL patterns are qualified by appending to
their `String` representation, a colon separated representation of the
list of patterns that qualify the pattern. Duplicates must not be
included in the list of qualifying patterns, and any qualifying pattern
matched by another qualifying pattern mayfootnote:[Qualifying patterns implied by another qualifying pattern may be dropped because the use of the reduced list to qualify a pattern will yield a `URLPatternSpec` “equal” to the `URLPatternSpec` produced by qualifying the pattern with the full list (for example, pass:[/a/*:/ a/b:/a/b/*:/a/b/c/*] is equal to pass:[/a/*:/a/b/*)]] 
be
dropped from the list.

```
QualifyingPatternList ::=
    empty string | colon QualifyingPattern |
    QualifyingPatternList colon QualifyingPattern

QualifiedPattern ::= Pattern QualifyingPatternList
```


All colon characters occurring within Pattern
and QualifyingPattern elements must be transformed to escaped
encodingfootnote:[See <<a839>> for details.] prior to inclusion of the corresponding
element in the QualifiedPattern.

Any pattern, qualified by a pattern that
matches it, is overridden and made irrelevant (in the translation) by
the qualifying pattern. Specifically, all extension patterns and the
default pattern are made irrelevant by the presence of the path prefix
pattern pass:["/*"] in a deployment descriptor. Patterns qualified by the pass:["/*"]
pattern violate the URLPatternSpec constraints of `WebResourcePermission`
and `WebUserDataPermission` names and must be rejected by the
corresponding permission constructors.

[[a302, "Combining HTTP Methods"]]
*Combining HTTP Methods*

The section defines the rules for combining
HTTP method names occurring in `web-resource-collection` elements that
apply to a common `url-pattern`. The rules are commutative and
associative and are as follows:

* Lists of `http-method` elements combine to
yield a list of `http-method` elements containing the union (without
duplicates) of the `http-method` elements that occur in the individual
lists.
* Lists of `http-method-omission` elements
combine to yield a list containing only the `http-method-omission`
elements that occur in all of the individual lists (i.e., the
intersection).
* A list of `http-method-omission` elements
combines with a list of `http-method` elements to yield the list of
`http-method-omission` elements minus any elements whose method name
occurs in the `http-method` list.
* An empty list (of `http-method` and
`http-method-omission` elements) represents the set of all possible HTTP
methods, including when it results from combination according to the
rules described in this section. An empty list combines with any other
list to yield the empty list.

When these combining rules are applied to a
list of collections, the result is always either an empty list, a
non-empty list of `http-method` elements, or a non-empty list of
`http-method-omission` elements. When the result is an empty list, the
corresponding actions value is the null (or the empty string) value.
When the result is a non-empty list of `http-method` elements the
corresponding actions value is a comma separated list of the HTTP method
names occurring in the `http-method` elements of the list. When the
result is a non-empty list of `http-method-omission` elements the
corresponding actions value is an HTTP method exception list (as defined
in <<a318>>)
containing the HTTP method names occurring in the `http-method-omission`
elements of the list. The following table contains the three alternative
combination results and their corresponding actions values.


[caption="Table {doc-part}-{counter:table-number} ", title="HTTP Method Combination to Actions Correspondence"]
[.center, width=75%]
[%header,cols="40%^,60%^"] 
|===
^| Combination Result ^| Actions Value
^a| [.small]#+++<font size=".8em">empty list</font>+++# 
^a| [.small]#+++<font size=".8em">null or empty string</font>+++#

^a| [.small]#+++<font size=".8em">list of http-method elements</font>+++# 
^a| [.small]#+++<font size=".8em">HttpMethodList (e.g., “GET,POST”)</font>+++#

^a| [.small]#+++<font size=".8em">list of http-method-omission elements</font>+++# 
^a| [.small]#+++<font size=".8em">HttpMethodExceptionList (e.g.,”!PUT,DELETE”)</font>+++#
|===

[[a318, "HTTP Method Exception List"]]
*HTTP Method Exception List*

An HTTP method exception list is used to
represent, by set difference, a non-enumerable subset of the set of all
possible HTTP methods. An exception list represents the subset of the
complete set of HTTP methods formed by subtracting the methods named in
the exception list from the complete set.

An exception list is distinguished by its
first character, which must be the exclamation point (i.e., “!”)
character. A comma separated list of one or more HTTP method names must
follow the exclamation point. The syntax of an HTTP method list is
formally defined as follows:

```
ExtensionMethod ::= any token as defined by IETF RFC 2616
    (i.e., 1*[any CHAR except CTLS or separators as defined in RFC 2616])

HTTPMethod ::= “GET” | “POST” | “PUT” | “DELETE” | “HEAD” |
    “OPTIONS” | “TRACE” | ExtensionMethod

HTTPMethodList ::= HTTPMethod | HTTPMethodList comma HTTPMethod

HTTPMethodExceptionList ::= exclaimationPoint HTTPMethodList
```

[[a330, "Mapping Transport Guarantee to Connection Type"]]
*Mapping Transport Guarantee to Connection Type*

A `transport-guarantee` (in a
`user-data-constraint` ) of NONE, or a `security-constraint` without a
`user-data-constraint` , indicates that the associated URL patterns and
HTTP methods may be accessed over any (including an unprotected)
transport. A `transport-guarantee` of INTEGRAL indicates that acceptable
connections are those deemed by the container to be integrity protected.
A `transport-guarantee` of CONFIDENTIAL indicates that acceptable
connections are those deemed by the container to be protected for
confidentiality.

[[a332]]
[caption="Table {doc-part}-{counter:table-number} ", title="transport-guarantee to Acceptable Connection Mapping"]
[.center, width=75%]
[%header,cols="40%^,60%^"] 
|===
^| transport-guarantee in constraint ^| connection type String value
^a| [.small]#+++<font size=".8em">INTEGRAL</font>+++# 
^a| [.small]#+++<font size=".8em">":INTEGRAL"</font>+++#

^a| [.small]#+++<font size=".8em">CONFIDENTIAL</font>+++# 
^a| [.small]#+++<font size=".8em">":CONFIDENTIAL"</font>+++#

^a| [.small]#+++<font size=".8em">NONE (including no user-data-constraint)</font>+++# 
^a| [.small]#+++<font size=".8em">null</font>+++#
|===

[[a343]]
===== Translating Servlet security-role-ref Elements

For each `security-role-ref` appearing in the deployment descriptor a 
corresponding `WebRoleRefPermission` must be added to the corresponding role. 
The name of the `WebRoleRefPermission` must be the `servlet-name` in whose 
context the `security-role-ref` is defined. The actions of the 
`WebRoleRefPermission` must be the value of the
`role-name` (that is the reference), appearing in the
`security-role-ref`. The deployment tools must call the `addToRole`
method on the `PolicyConfiguration` object to add the
`WebRoleRefPermission` object resulting from the translation to the `role`
identified in the `role-link` appearing in the `security-role-ref`.

Additional `WebRoleRefPermission` objects must
be added to the `PolicyConfiguration` as follows. For each servlet element
in the deployment descriptor a `WebRoleRefPermission` must be added to
each `security-role` of the application whose name does not appear as
the `role-name` in a `security-role-ref` within the servlet element. If
the “any authenticated user” `role-name`, pass:[“**”], does not appear in a
`security-role-ref` within the servlet, a `WebRoleRefPermission` must also
be added for it. The name of each such `WebRoleRefPermission` must be the
`servlet-name` of the corresponding servlet element. The actions (that is,
reference) of each such `WebRoleRefPermission` must be the corresponding
(non-appearing) `role-name`. The resulting permissions must be added to
the corresponding roles by calling the `addToRole` method on the
`PolicyConfiguration` object.

For each `security-role` defined in the
deployment descriptor and the “any authenticated user” role, pass:[“**”], an
additional `WebRoleRefPermission` mustfootnote:[These additional `WebRoleRefPermission` objects support the use of `isUserInRole` from unmapped (to a Servlet) JSP components.]
be added to
the corresponding role by calling the `addToRole` method on the
`PolicyConfiguration` object. The name of all such permissions must be the
empty string, and the actions of each such permission must be the
`role-name` of the corresponding role.

[[a347]]
===== Servlet URL-Pattern Matching Rules

This URL pattern matches another pattern if
they are related, by case sensitive comparison, as follows:

* their pattern values are String equivalent, or
* this pattern is the path-prefix pattern pass:["/*"], or
* this pattern is a path-prefix pattern (that is, it starts with "/" and ends with pass:["/*"]) and the other pattern starts
with the substring of this pattern, minus its last 2 characters, and the next character of the other pattern, if there is one, is "/", or
* this pattern is an extension pattern (that is, it starts with pass:["*."]) and the other pattern ends with this pattern, or
* this pattern is the special default pattern, "/", which matches all other patterns.

[[a3322]]
[caption="Table {doc-part}-{counter:table-number} ", title="url-pattern Types by Example"]
[.center, width=65%]
[%header,cols="30%^,70%^"] 
|===
^| pattern type ^| example
^a| [.small]#+++<font size=".8em">exact</font>+++# 
^a| [.small]#+++<font size=".8em">/acme/widget/hammer</font>+++#

^a| [.small]#+++<font size=".8em">path prefix</font>+++# 
^a| [.small]#+++<font size=".8em">/acme/widget/*</font>+++#

^a| [.small]#+++<font size=".8em">extension</font>+++# 
^a| [.small]#+++<font size=".8em">*.html</font>+++# 

^a| [.small]#+++<font size=".8em">default</font>+++#
^a| [.small]#+++<font size=".8em">/</font>+++#
|===

[[a354]]
===== Example

This example demonstrates the `WebResourcePermission` and 
`WebUserDataPermission` objects that would
result from the translation of a deployment descriptor that contained
the following `security-constraint` elements.

[source,xml]
----
<!--
    The following security-constraint excludes access to the patterns and method 
    combinations defined by the two contained web-resource-collections. 
    
    The first collection excludes access
    by all methods except GET and POST, while the second collection excludes
    access by all HTTP methods.
-->
<security-constraint>
    <web-resource-collection>
        <web-resource-name>sc1.c1</web-resource-name>
            <url-pattern>/a/*</url-pattern>
            <url-pattern>/b/*</url-pattern>
            <url-pattern>/a</url-pattern>
            <url-pattern>/b</url-pattern>
            <http-method-omission>GET</http-method-omission>
            <http-method-omission>POST</http-method-omission>
    </web-resource-collection>

    <web-resource-collection>
        <web-resource-name>sc1.c2</web-resource-name>
        <url-pattern>*.asp</url-pattern>
    </web-resource-collection>

    <auth-constraint/>
</security-constraint>

<!--
    The following security-constraint restricts access to the patterns and method 
    combinations defined by the two contained web-resource-collections to callers 
    in role R1 who connect using a confidential transport.
-->
<security-constraint>
    <web-resource-collection>
        <web-resource-name>sc2.c1</web-resource-name>
        <url-pattern>/a/*</url-pattern>
        <url-pattern>/b/*</url-pattern>
        <http-method>GET</http-method>
    </web-resource-collection>
    
    <web-resource-collection>
        <web-resource-name>sc2.c2</web-resource-name>
        <url-pattern>/b/*</url-pattern>
        <http-method>POST</http-method>
    </web-resource-collection>

    <auth-constraint>
        <role-name>R1</role-name>
    </auth-constraint>

    <user-data-constraint>
        <transport-guarantee>CONFIDENTIAL</transport-guarantee>
    </user-data-constraint>

</security-constraint>
----


<<a399>> contains the qualified URL pattern names
that would result from the translation of the `security-constraint`
elements (including the qualified form of the default pattern). The
second column of <<a399>> contains the canonical form of the qualified names.
The values in the second column have been derived from the values in the
first column by removing qualifying patterns matched by other qualifying
patterns.

[[a399]]
[caption="Table {doc-part}-{counter:table-number} ", title="Qualified URL Pattern Names from Example"]
[.center, width=65%]
[%header,cols="30%^,70%^"] 
|===
^| Qualified URL Pattern Name type ^| Canonical Form
^a| [.small]#+++<font size=".8em">/a</font>+++# 
^a| [.small]#+++<font size=".8em">"/a</font>+++#

^a| [.small]#+++<font size=".8em">/b</font>+++# 
^a| [.small]#+++<font size=".8em">/b</font>+++#

^a| [.small]#+++<font size=".8em">pass:[/a/*:/a]</font>+++# 
^a| [.small]#+++<font size=".8em">pass:[/a/*:/a]</font>+++# 

^a| [.small]#+++<font size=".8em">pass:[/b/*:/b]</font>+++#
^a| [.small]#+++<font size=".8em">pass:[/b/*:/b]</font>+++#

^a| [.small]#+++<font size=".8em">pass:[/b/*:/b]</font>+++#
^a| [.small]#+++<font size=".8em">pass:[/b/*:/b]</font>+++#

^a| [.small]#+++<font size=".8em">pass:[*.asp:/a/*:/b/*]</font>+++#
^a| [.small]#+++<font size=".8em">pass:[*.asp:/a/*:/b/*]</font>+++#

^a| [.small]#+++<font size=".8em">pass:[/:/a:/b:/a/*:/b/*:*.asp]</font>+++#
^a| [.small]#+++<font size=".8em">pass:[/:/a/*:/b/*:*.asp]</font>+++#

|=== 

<<a416>> represents the
permissions and `PolicyConfiguration` operations that would result from
the translation of the security-constraint elements.The names appearing
in the second column of the table are those found in the first column of
<<a399>>. As noted previously, any equivalent form of the qualified
names, including their canonical forms, could have been used in the
permission constructions.


[[a416]]
[caption="Table {doc-part}-{counter:table-number} ", title="Permissions and PolicyConfiguration Operations from Example"]
[.center, width=75%]
[%header,cols="20%,25%,30%,25%"] 
|===
^| Permission Type ^| Name ^| Actions ^| Policy Configuration Add To
^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/a/*:/a</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++# 

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/a/*:/a</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/b/*:/b</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/b/*:/b</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/a</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/a</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++# 

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/b</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/b</font>+++#
^a| [.small]#+++<font size=".8em">!GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">*.asp:/a/*:/b/*</font>+++#
^a| null
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">*.asp:/a/*:/b/*</font>+++#
^a| [.small]#+++<font size=".8em">null</font>+++# 
^a| [.small]#+++<font size=".8em">excluded</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/a/*:/a</font>+++#
^a| [.small]#+++<font size=".8em">GET</font>+++# 
^a| [.small]#+++<font size=".8em">role(R1)</font>+++# 

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/b/*:/b</font>+++#
^a| [.small]#+++<font size=".8em">GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">role(R1)</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/a/*:/a</font>+++#
^a| [.small]#+++<font size=".8em">GET:CONFIDENTIAL</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/b/*:/b</font>+++#
^a| [.small]#+++<font size=".8em">GET,POST:CONFIDENTIAL</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/a/*:/a</font>+++#
^a| [.small]#+++<font size=".8em">POST</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/a/*:/a</font>+++#
^a| [.small]#+++<font size=".8em">POST</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++# 

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/a</font>+++#
^a| [.small]#+++<font size=".8em">GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/a</font>+++#
^a| [.small]#+++<font size=".8em">GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/b</font>+++#
^a| [.small]#+++<font size=".8em">GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/b</font>+++#
^a| [.small]#+++<font size=".8em">GET,POST</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

^a| [.small]#+++<font size=".8em">WebResource</font>+++# 
^a| [.small]#+++<font size=".8em">/:/a:/b:/a/*:/b/*:*.asp</font>+++#
^a| [.small]#+++<font size=".8em">null</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++# 

^a| [.small]#+++<font size=".8em">WebUserData</font>+++# 
^a| [.small]#+++<font size=".8em">/:/a:/b:/a/*:/b/*:*.asp</font>+++#
^a| [.small]#+++<font size=".8em">null</font>+++# 
^a| [.small]#+++<font size=".8em">unchecked</font>+++#

|=== 

Regarding the `null` in the third column of <<a416>>; the canonical form for the set of all HTTP Methods (including all extension methods) is null.

[[a512]]
==== Jakarta Enterprise Beans Policy Context Identifiers

To satisfy this specification, an application
server must establish Jakarta Enterprise Beans policy context identifiers sufficient to
differentiate all instances of the deployment of an Jakarta Enterprise Beans jar on the
application server, or on any other application server with which the
server may share the same policy statement repository.

When an application is composed of multiple
Jakarta Enterprise Beans jars, no two jars that share at least one `ejb-name` value in common
may share the same policy context identifiers.

In cases where Jakarta Enterprise Beans may be packaged in war
files, the application server must assign the Jakarta Enterprise Beans to a policy context
distinct from that to which any web components are assigned.

[[a516]]
==== Translating Jakarta Enterprise Beans Deployment Descriptors

A reference to a `PolicyConfiguration` object
must be obtained by calling the `getPolicyConfiguration` method on the
`PolicyConfigurationFactory` implementation class of the provider
configured into the container. The policy context identifier used in the
call to `getPolicyConfiguration` must be a `String` that satisfies the
requirements described in <<a512>>. The `method-permission`, `exclude-list,` and
`security-role-ref` elements appearing in the deployment descriptor must
be translated into permissions and added to the `PolicyConfiguration`
object to yield an equivalent translation as that defined in the
following sections and such that every Jakarta Enterprise Beans method for which the
container performs pre-dispatch access decisions is implied by at least
one permission resulting from the translation. Before the translation is
performed, all policy statements must have been
removedfootnote:[This can be achieved by passing `true` as the second parameter in the call to `getPolicyConfiguration`, or by calling `delete` on the `PolicyConfiguration` before calling `getPolicyConfiguration` to transition it to the open state.] from the policy context associated with
the returned `PolicyConfiguration`.

[[a518]]
===== Translating Jakarta Enterprise Beans method-permission Elements

For each `method` element of each
`method-permission` element, an `EJBMethodPermission` object translated from
the `method` element must be added to the policy statements of the
`PolicyConfiguration` object. The name of each such `EJBMethodPermission`
object must be the `ejb-name` from the corresponding `method` element, and
the actions must be established by translating the `method` element into
a method specification according to the methodSpec syntax defined in the
documentation of the `EJBMethodPermission` class. The actions translation
must preserve the degree of specificity with respect to `method-name`,
`method-intf`, and `method-params` inherent in the method element.

If the `method-permission` element contains
the `unchecked` element, then the deployment tools must call the
`addToUncheckedPolicy` method to add the permissions resulting from the
translation to the `PolicyConfiguration` object. Alternatively, if the
`method-permission` element contains one or more `role-name` elements,
then the deployment tools must call the `addToRole` method to add the
permissions resulting from the translation to the corresponding roles of
the `PolicyConfiguration` object. These `addToRole` calls must be made for
any `role-name` used in the `method-permision` which may include the
role-name pass:[“**”]; which, by default, is mapped to any authenticated user.

[[a521]]
===== Translating the Jakarta Enterprise Beans exclude-list

An `EJBMethodPermission` object must be created
for each `method` element occurring in the `exclude-list` element of the
deployment descriptor. The name and actions of each `EJBMethodPermission`
must be established as described in <<a518>>

The deployment tools must use the
`addToExcludedPolicy` method to add the `EJBMethodPermission` objects
resulting from the translation of the `exclude-list` to the excluded
policy statements of the `PolicyConfiguration` object.

[[a524]]
===== Translating Jakarta Enterprise Beans security-role-ref Elements

For each `security-role-ref` element
appearing in the deployment descriptor, a corresponding
`EJBRoleRefPermission` must be created. The value of the `ejb-name` element
within the element containing the `security-role-ref` element must be used
as the name of the `EJBRoleRefPermission`. The actions used to construct
the permission must be the value of the `role-name` (that is the
reference), appearing in the `security-role-ref`. The deployment tools
must call the `addToRole` method on the `PolicyConfiguration` object to
add a policy statement corresponding to the `EJBRoleRefPermission` to the
role identified in the `role-link` appearing in the `security-role-ref`.

Additional `EJBRoleRefPermission` objects must
be added to the `PolicyConfiguration` as follows. For each element in the
deployment descriptor for which the Jakarta Enterprise Beans descriptor schema
supportsfootnote:[Jakarta Enterprise Beans supports inclusion of `security-role-ref` elements in entity and session elements. Future versions could support inclusion in `message-driven`.] inclusion of `security-role-ref` elements,
an EJBRoleRefPermission must be added to each `security-role` of the
application whose name does not appear as the `role-name` in a
`security-role-ref` within the element. If the “any authenticated user”
`role-name` , pass:[“**”], does not appear in a `security-role-ref` within the
element, a `EJBRoleRefPermission` must also be added for it. The name of
each such `EJBRoleRefPermission` must be the value of the `ejb-name` element
within the element in which the `security-role-ref` elements could
otherwise occur. The actions (that is, reference) of each such
`EJBRoleRefPermission` must be the corresponding (non-appearing)
`role-name` . The resulting permissions must be
addedfootnote:[For example, if an application declares roles {R1, R2, R3} and defines a session Jakarta Enterprise Bean
named “shoppingCart” that contains one `security-role-ref` element with `role-name` R1, then an additional `EJBRoleRefPermission` must be added to each of the roles R2 and R3. The name of both permissions must be “shoppingCart”, and the actions value of the permission added to role R2 must be “R2”, and the actions value of the permission added to role R3 must be “R3”.]
to the corresponding roles by calling the
`addToRole` method on the `PolicyConfiguration` object.

[[a527]]
==== Deploying an Application or Module

The application server’s deployment tools
must translate the declarative authorization policy appearing in the
application or module deployment descriptor(s) into policy statements
within the `Policy` providers used by the containers to which the
components of the application or module are being deployed. In Jakarta Servlet
containers, the policy statements resulting from the deployment and
initialization of a web module, must represent the effects of any
programmatic registration and security configuration of servlets that
occurred during the initialization of the module.

When a module is deployed, its policy context
must be linked to all the other policy contexts with which it must share
the same principal-to-role mapping. When an application is deployed,
every policy context of the application must be linked to every other
policy context of the application with which it shares a common Policy
provider. `Policy` contexts are linkedfootnote:[Policy context linking is transitive and symmetric, and this specification should not be interpreted as requiring that linkConfiguration be called on every combination of policy contexts that must share the same principal-to-role mapping, or that all contexts must be linked before any can be committed.] 
by calling the linkConfiguration method on the `PolicyConfiguration` objects of the
provider.

After the translation and linking has
occurred (note that they may occur in either order) for a policy
context, the `commit` method must be called on the corresponding
`PolicyConfiguration` object to place it in service such that its policy
statements will be assimilated by the corresponding `Policy` providers.
These three operations, translate, link and commit, must be performed
for all of the policy contexts of the application.

Once the translation, linking, and committing
has occurred, a call must be made to `Policy.refresh` on the Policy
provider used by each of the containers to which the application or
module is being deployed. The calls to `Policy.refresh` must occur
before the containers will accept requests for the deployed resources.
If a module corresponding to a policy context may have inter-module,
initialization-time, dependencies that must be satisfied before the
translation of the policy context of the dependent module can be
completedfootnote:[Such as having a Jakarta Servlet `ServletContextListener` configured that could programmatically register a servlet and configure its security constraints and that could also perform a local invocation of a Jakarta Enterprise Bean in another module of the application.], 
the `commit` of the depended upon
modules must occur before the initialization of the dependent module,
and the calls to `Policy.refresh` described above must additionally
occur after the processing of the depended upon modules and before the
initialization of the dependent module.

The policy context identifiers corresponding
to the deployed application or module must be recorded in the
application server so that they can be used by containers to establish
the policy context as required by <<a707>> of the <<a556>>, and such that the Deployer
may subsequently remove or modify the corresponding policy contexts as a
result of the undeployment or redeployment of the application.

[[a533]]
==== Undeploying an Application or Module

To ensure that there is not a period during
undeployment when the removal of policy statements on application
components renders what were protected components unprotected, the
application server must stop dispatching requests for the application’s
components before undeploying an application or module.

To undeploy an application or module, the
deployment tools must indicate at all the `Policy` providers to which
policy contexts of the application or module have been deployed that the
policy contexts associated with the application or module that have been
configured in the provider are to be removed from service. A deployment
tool indicates that a policy context is to be removed from service
either by calling `getPolicyConfiguration` with the identifier of the
policy context on the provider’s `PolicyConfigurationFactory` or by
calling delete on the corresponding `PolicyConfiguration` object. If the
`getPolicyConfiguration` method is used, the value `true` should be passed
as the second argument to cause the corresponding policy statements to
be deleted from the context. After the policy contexts are marked for
removal from service, a call must be made to `Policy.refresh` on all of
the `Policy` providers from which at least one module of the application
or module was marked for removal from service.

[[a536]]
==== Deploying to an existing Policy Configuration

Containers are not required to deploy to an
existing policy configuration. Containers that chose to provide this
functionality must satisfy the following requirements.

To associate an application or module with an
existing set of linked policy contexts, the identifiers of the existing
policy contexts must be applied by the relevant containers in fulfilling
their obligations as defined in the <<a556>>. The policy contexts should
be verified for existence, by calling the `inService` method of the
`PolicyConfigurationFactory` of the Policy providers of the relevant
containers. The deployment tools must call `Policy.refresh` on the
Policy provider of each of the relevant containers, and the containers
must not perform pre-dispatch decisions or dispatch requests for the
deployed resources until these calls have completed.

In Jakarta Servlet containers, if any
programmatic registration and security configuration of servlets has
occurred during the initialization of a web module associated with a
pre-exiting policy context, the corresponding `PolicyConfiguration` object
must be opened, its policy statements must be removed, and the policy
translation of the module must be repeated to include the programmatic
effects. The `PolicyConfiguration` object must be committed, and an
additional call to `Policy.refresh` must be made after all such
`PolicyConfiguration` objects are committed.

[[a540]]
==== Redeploying a Module

Containers are not required to implement
redeployment functionality. Containers that chose to provide this
functionality must satisfy the following requirements.

To ensure redeployment does not create a
situation where the removal of policy statements on application
components renders what were protected components unprotected, the
application server must stop dispatching requests for the application’s
components before redeployment begins. The application server must not
resume dispatching requests for the application’s components until after
the calls to `Policy.refresh`, described in <<a527>>,
have completed.

To redeploy a module, the deployment tools
must indicate at all of the Policy providers to which the module is to
be redeployed that the policy context associated with the module is to
be removed from service. If the module is to be redeployed to the same
policy context at a provider, all policy statements and linkages must be
removed from the policy context at the provider. After the policy
contexts have been marked for removal from service and emptied of policy
statements and linkages (as necessary), the deployment tools must
proceed as described in <<a527>>.

[[a544]]
=== What the Provider Must Do

The provider must include an implementation
of the `jakarta.security.jacc.PolicyConfigurationFactory` class along with
a matched implementation of a class that implements the
`jakarta.security.jacc.PolicyConfiguration` interface. In addition to
providing a `PolicyConfiguration` interface for integration with the
application server’s deployment tools, the provider must also include a
management interface for policy administrators to use to grant the
collections of permissions that comprise roles, to principals. This
interface need not be standardized.

The provider must ensure that all of the
permissions added to a role in a policy context are granted to any
principal mapped to the role by the policy administrator. For the any
“authenticated user role”, pass:[“**”], and unless an application specific
mapping has been established for this role, the provider must ensure
that all permissions added to the role are granted to any authenticated
user. The provider must ensure that the same principal-to-role mappings
are applied to all linked policy contexts.

The provider must ensure that excluded policy
statements take precedence over overlapping unchecked policy statements,
and that both excluded and unchecked policy statements take precedence
over overlapping role based policy statements.

This specification does not prescribe the
policy language or the methods used within providers to implement the
policy and role requirements described above.

